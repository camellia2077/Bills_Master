# Bills_Master
记账程序

# struct
```
Bills_Master/
├── Inserter/
│   ├── __init__.py
│   └── database_inserter.py
│
├── Query/
│   ├── __init__.py
│   └── query_db.py
│
├── Reprocessor/
│   ├── __init__.py
│   ├── BillProcessor.py
│   ├── bill_modifier.py
│   ├── bill_validator.py
│   └── status_logger.py
│
├── TextParser/
│   ├── __init__.py
│   └── text_parser.py
│
├── config/
│   ├── modifier_config.json
│   └── validator_config.json
│
├── common.py
└── main.py

```

# Reprocessor
## bill_validator.py
1. 配置文件解析与准备
首先，程序依赖一个外部的 JSON config 文件来定义什么是“有效”的账单结构。

加载配置: _load_config 函数会读取并解析这个 JSON 文件。

转换配置: _transform_config_for_validation 函数会将 JSON 中定义的层级结构（父项和其下的子项列表）转换成一个简单的字典（validation_map）。这个字典的键是“父标题”，值是该父标题下所有合法的“子标题”列表。

配置有效性检查: 如果配置文件格式不正确（例如，缺少 categories 列表）或为空，程序会立即报错并终止。

简而言之，配置文件定义了账单中所有合法的父标题及其对应的子标题，这是所有后续验证的基础。

2. 文件结构验证
程序逐行读取账单文件，并验证其基本结构是否正确。

a. 文件头部验证 (_validate_date_and_remark)
程序期望文件的前两行必须是 DATE 和 REMARK：

第一行 (DATE): 必须严格遵循 DATE:YYYYMM 的格式，即以 DATE: 开头，后跟6位数字。

正确示例: DATE:202507

错误示例: DATE:2025-07, DATE: 250701, DATE:

第二行 (REMARK): 必须以 REMARK: 开头，后面的内容可以是任意字符。

正确示例: REMARK:七月份日常开销

错误示例: Note: some text

如果文件少于两行，或者前两行不符合上述格式，则会报告错误。

b. 文件主体层级验证
从第三行开始，程序使用一个状态机 (expecting 变量) 来验证文件的层级结构是否为 父标题 -> 子标题 -> 内容行 的顺序。

父标题 (_handle_parent_state):

合法性: 一个被视作父标题的行，其内容必须存在于配置文件的父标题列表中。

格式: 程序隐式地通过检查它是否存在于配置中来验证它。如果一个行看起来像标题（^[A-Z]+[\u4e00-\u9fff]+[\d]*$，即大写字母+汉字+可选数字）但不在配置中，就会报错。

错误情况:

如果程序期望一个父标题，但读到的行不符合格式，会报错：“期望一个在配置文件中定义的父级标题, 但找到不匹配的内容”。

如果读到的行符合标题格式但不在配置文件中，会报错：“父标题 '...' 不在配置文件中”。

子标题 (_handle_sub_state):

合法性: 在读到一个父标题后，程序期望读到一个子标题。这个子标题必须是当前父标题在配置文件中指定的合法子项之一。

错误情况:

如果读到的行对于当前父标题来说是无效的子标题，会报错：“子标题 '...' 对于父级标题 '...' 无效”。

如果在一个父标题后，没有跟任何子标题，而是直接开始了下一个父标题，会报错：“父级标题 '...' 缺少子标题”。

内容行 (_handle_content_state):

格式: 在读到一个子标题后，程序期望读到具体的内容行。内容行必须符合一个特定的正则表达式：^\d+(?:\.\d+)?(?:[^\d\s][\d\u4e00-\u9fffa-zA-Z_-]*)+$。这个格式意味着：

以一个数字（整数或小数）开头。

后面紧跟着至少一个非数字、非空格的字符。

再后面是任意数量的数字、汉字、字母、下划线或连字符的组合。

正确示例: 25.5水果, 1000房租-7月, 50item_A

错误示例: 一些描述 (没有数字开头), 25.5 (数字后没有描述)

错误情况: 如果程序期望读到内容行，但实际读到的行不符合内容行格式，也不是一个新的有效父/子标题，就会报错：“期望内容行、配置文件中有效的子标题或父标题, 但找到其他内容”。

3. 内容逻辑和完整性验证
除了结构，程序还进行逻辑检查，以确保账单的完整性，这部分主要由 _post_validation_checks 和散布在各状态处理函数中的逻辑完成。

父标题必须有子标题: 程序会检查所有出现过的父标题，确保每个父标题下至少跟随了一个子标题。如果没有，这会被标记为一个 错误 (Error)。

触发条件: 文件中出现 "交通支出" 这个父标题，但下面没有任何子标题（如 "公交", "打车"），直接就是下一个父标题 "餐饮支出"。

错误信息: "父级标题 '...' 缺少子标题"。

子标题应该有内容行: 程序会检查所有出现过的子标题，确保其后至少跟随了一行内容。如果一个子标题下没有任何内容行，这会被标记为一个 警告 (Warning)。

触发条件: 文件中出现 "餐饮支出" -> "午餐"，但 "午餐" 下面没有具体的开销记录，而是直接开始了下一个子标题 "晚餐"。

警告信息: "子标题 '...' 缺少内容行"。

父标题下不应全部为空: 如果一个父标题下的所有子标题都没有任何内容行，这也会被标记为一个 警告 (Warning)。

触发条件: "娱乐支出" 下有 "电影" 和 "游戏" 两个子标题，但这两个子标题下面都没有任何具体消费记录。

警告信息: "父标题 '...' 的所有子标题均缺少内容行"。

## bill_modifier.py

好的，通过对 bill_modifier.py Python 脚本和 Modifier_Config.json 配置文件的分析，可以详细地解释这个程序对传入的文本文件所做的修改。

这个程序的核心功能是一个账单文件修改器。它会读取一个特定格式的文本文件（账单），并根据 Modifier_Config.json 文件中的规则，自动对这个账单进行计算、内容添加、排序、清理和格式化。

根据配置文件，所有四项核心功能（计算、自动续费、清理、排序）都被激活了。下面是程序将对文本文件进行的具体修改步骤：

修改流程总览
程序处理文件的过程分为两个主要阶段：

初始修改 (_perform_initial_modifications)：这个阶段直接在文件行上操作，主要处理“求和计算”和“自动续费项添加”。

结构化修改 (_process_structured_modifications)：这个阶段会将文件内容解析成一个层级结构（父项 -> 子项 -> 内容），然后在这个结构上执行“排序”和“清理”，最后根据规则重新生成整个文件内容，实现格式化。

具体修改内容详解
1. 表达式计算求和 (enable_summing: true)
程序会查找文件中包含加法表达式的行，并自动计算它们的总和。

识别对象：任何以 数字+数字... 格式开头的行。例如 25.5 + 30 + 10 物业费。

修改方式：程序会计算出表达式的总和，并用总和替换掉原来的表达式，同时保留后面的描述。

示例：

修改前:   20+50+30 某些费用

修改后:   100.00某些费用

相关函数: _sum_up_line, _perform_initial_modifications

2. 添加自动续费项 (enable_autorenewal: true)
程序会根据 Modifier_Config.json 中定义的规则，在指定的子类别下自动添加续费项目。

识别对象：程序会查找匹配 auto_renewal_rules 中键名的子类别标题。在当前的配置中，它会寻找名为 web_service 的子类别。

修改方式：一旦找到 web_service 这个子类别，程序会检查配置文件中定义的续费项（例如“迅雷加速器”）是否已经存在于该类别下。如果不存在，就会自动在 web_service 标题下方添加新的一行。

示例：

文本文件中存在:

web_service
修改后将自动添加:

web_service
25.00迅雷加速器(auto-renewal)
相关函数: _perform_initial_modifications

配置文件规则: "auto_renewal_rules": { "web_service": [{ "amount": 25.0, "description": "迅雷加速器" }] }

3. 内容排序 (enable_sorting: true)
在完成初始修改后，程序会对每个子类别下的所有条目（内容行）进行排序。

识别对象：所有子类别（例如 web_service）下的账单条目。

修改方式：排序主要依据是每行开头的数字，按照从大到小的顺序排列。如果数字相同，则会再根据整个字符串的内容进行排序。

示例：

修改前:

some_category
15.00项目A
300.50项目C
80.00项目B
修改后:

some_category
300.50项目C
80.00项目B
15.00项目A
相关函数: _sort_bill_structure, _get_numeric_value_from_content

4. 清理空项目 (enable_cleanup: true)
排序后，程序会清理掉那些没有任何有效内容的类别。

识别对象：

不包含任何内容行的子类别。

所有子类别都被清理后，变为空的父类别。

修改方式：直接将这些空的类别标题从文件中删除。

示例：

修改前:

父类别A

    子类别_a1
        100.00条目1

    子类别_a2

父类别B

    子类别_b1
修改后 (子类别_a2 和 父类别B 因为没有内容而被删除):

父类别A

    子类别_a1
        100.00条目1
相关函数: _cleanup_bill_structure

5. 全文格式化
在完成所有内容修改后，程序会根据 formatting_rules 中的规则，重新生成整个文本文件的内容，以统一格式。

修改方式：

父类别之间：会插入4个空行 (lines_after_parent_section: 4)。

父类别标题和其下的第一个子类别之间：会插入1个空行 (lines_after_parent_title: 1)。

子类别之间：会插入1个空行 (lines_between_sub_items: 1)。

所有行前后的多余空格会被移除。

相关函数: _reconstruct_content_with_formatting
